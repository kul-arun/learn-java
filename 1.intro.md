# Introduction to Java

* A solid object-oriented language that was inspired by C++.
* The dev team tried to make the Java better than C++ via good design principles, that they learned through their
  experiences with C++.
* Modern Java has introduced a lot of Functional Programming concepts, which is important for big data and massively
  parallel computations. Also, modern hardware is not getting faster, but more parallel (more cores in the CPU).
* Core Java comes with many libraries (more than 4700 classes), third-party would be much higher.
* Java runs on the JVM platform which is efficient and secure.


## Java's Execution Model
* Before Java, programming languages were either compiled or interpreted.
* **Compiled language** -> Human-readable source code is used to generate machine-readable binary code that can directly
  execute on the target CPU. This is done via a compiler. The generated code is specific to an OS and machine
  architecture. Same source code can be used to generate machine code for a different OS or machine if a compiler exists
  for it.
* **Interpreted language** -> At runtime, the human-readable source code is read line by line and executed by an
  interpreter.
* For compiled languages, the whole source code is checked once and machine code is generated for program execution. But
  in the case of interpreter languages, the code is checked at run time when the program executes. So the code has to be
  checked and also executed during runtime. This slows down interpreted languages.
* Java took a unique approach to get the best of both: Source code is used by a Java compiler to generate byte code,
  which targets a simulated (virtual) machine. Here, the program is analyzed before runtime (like in compiled languages)
  and this prevents slowdowns that affect the traditional interpreted languages. Also the generated code is very easy to
  interpret efficiently. Code runs on an interpreter and so it can run on any machine if interpreter is present on it.
* Modern JVMs can do runtime optimizations by looking at the running program. Hotspots (regions of code that are run
  frequently, like certain code in some loop) when identified can be converted by the JVM from platform independent
  bytecode into native machine code for the host CPU via a secondary compilation step.
